// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
)

const createActualAlbumPartition = `-- name: CreateActualAlbumPartition :exec
SELECT create_actual_album_partition($1::int)
`

func (q *Queries) CreateActualAlbumPartition(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, createActualAlbumPartition, version)
	return err
}

const createActualVersion = `-- name: CreateActualVersion :one
INSERT INTO actual_version (published)
VALUES (FALSE)
RETURNING version_id,
	created_at,
	published
`

func (q *Queries) CreateActualVersion(ctx context.Context) (ActualVersion, error) {
	row := q.db.QueryRow(ctx, createActualVersion)
	var i ActualVersion
	err := row.Scan(&i.VersionID, &i.CreatedAt, &i.Published)
	return i, err
}

const createLocalAlbumPartition = `-- name: CreateLocalAlbumPartition :exec
SELECT create_local_album_partition($1::int)
`

func (q *Queries) CreateLocalAlbumPartition(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, createLocalAlbumPartition, version)
	return err
}

const createLocalVersion = `-- name: CreateLocalVersion :one
INSERT INTO local_version (published)
VALUES (FALSE)
RETURNING version_id,
	created_at,
	published
`

func (q *Queries) CreateLocalVersion(ctx context.Context) (LocalVersion, error) {
	row := q.db.QueryRow(ctx, createLocalVersion)
	var i LocalVersion
	err := row.Scan(&i.VersionID, &i.CreatedAt, &i.Published)
	return i, err
}

const getActualAlbums = `-- name: GetActualAlbums :many
SELECT id, artist, name, year, kind, version_id
FROM actual_album_published
`

func (q *Queries) GetActualAlbums(ctx context.Context) ([]ActualAlbumPublished, error) {
	rows, err := q.db.Query(ctx, getActualAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActualAlbumPublished
	for rows.Next() {
		var i ActualAlbumPublished
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.Name,
			&i.Year,
			&i.Kind,
			&i.VersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAll = `-- name: GetAll :many
SELECT value,
	id
FROM cache
WHERE entity = $1
`

type GetAllRow struct {
	Value []byte
	ID    string
}

func (q *Queries) GetAll(ctx context.Context, entity string) ([]GetAllRow, error) {
	rows, err := q.db.Query(ctx, getAll, entity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRow
	for rows.Next() {
		var i GetAllRow
		if err := rows.Scan(&i.Value, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCache = `-- name: GetCache :one
SELECT value
FROM cache
WHERE entity = $1
	AND id = $2
`

type GetCacheParams struct {
	Entity string
	ID     string
}

func (q *Queries) GetCache(ctx context.Context, arg GetCacheParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCache, arg.Entity, arg.ID)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const getExcludedAlbums = `-- name: GetExcludedAlbums :many
SELECT artist,
	album
FROM excluded_album
`

func (q *Queries) GetExcludedAlbums(ctx context.Context) ([]ExcludedAlbum, error) {
	rows, err := q.db.Query(ctx, getExcludedAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExcludedAlbum
	for rows.Next() {
		var i ExcludedAlbum
		if err := rows.Scan(&i.Artist, &i.Album); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExcludedArtists = `-- name: GetExcludedArtists :many
SELECT artist
FROM excluded_artist
`

func (q *Queries) GetExcludedArtists(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getExcludedArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artist string
		if err := rows.Scan(&artist); err != nil {
			return nil, err
		}
		items = append(items, artist)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalAlbums = `-- name: GetLocalAlbums :many
SELECT artist, name, version_id
FROM local_album_published
`

func (q *Queries) GetLocalAlbums(ctx context.Context) ([]LocalAlbumPublished, error) {
	rows, err := q.db.Query(ctx, getLocalAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LocalAlbumPublished
	for rows.Next() {
		var i LocalAlbumPublished
		if err := rows.Scan(&i.Artist, &i.Name, &i.VersionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalArtists = `-- name: GetLocalArtists :many
SELECT DISTINCT artist
FROM local_album_published
`

func (q *Queries) GetLocalArtists(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getLocalArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artist string
		if err := rows.Scan(&artist); err != nil {
			return nil, err
		}
		items = append(items, artist)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertActualAlbum = `-- name: InsertActualAlbum :exec
INSERT INTO actual_album (id, artist, name, year, kind, version_id)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT DO NOTHING
`

type InsertActualAlbumParams struct {
	ID        string
	Artist    *string
	Name      *string
	Year      *int32
	Kind      *string
	VersionID int32
}

func (q *Queries) InsertActualAlbum(ctx context.Context, arg InsertActualAlbumParams) error {
	_, err := q.db.Exec(ctx, insertActualAlbum,
		arg.ID,
		arg.Artist,
		arg.Name,
		arg.Year,
		arg.Kind,
		arg.VersionID,
	)
	return err
}

const insertCache = `-- name: InsertCache :exec
INSERT INTO cache (entity, id, value)
VALUES ($1, $2, $3)
`

type InsertCacheParams struct {
	Entity string
	ID     string
	Value  []byte
}

func (q *Queries) InsertCache(ctx context.Context, arg InsertCacheParams) error {
	_, err := q.db.Exec(ctx, insertCache, arg.Entity, arg.ID, arg.Value)
	return err
}

const insertLocalAlbum = `-- name: InsertLocalAlbum :exec
INSERT INTO local_album (artist, name, version_id)
VALUES ($1, $2, $3) ON CONFLICT DO NOTHING
`

type InsertLocalAlbumParams struct {
	Artist    string
	Name      string
	VersionID int32
}

func (q *Queries) InsertLocalAlbum(ctx context.Context, arg InsertLocalAlbumParams) error {
	_, err := q.db.Exec(ctx, insertLocalAlbum, arg.Artist, arg.Name, arg.VersionID)
	return err
}

const publishActualVersion = `-- name: PublishActualVersion :exec
UPDATE actual_version
SET published = TRUE
WHERE version_id = $1::int
`

func (q *Queries) PublishActualVersion(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, publishActualVersion, version)
	return err
}

const publishLocalVersion = `-- name: PublishLocalVersion :exec
UPDATE local_version
SET published = TRUE
WHERE version_id = $1::int
`

func (q *Queries) PublishLocalVersion(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, publishLocalVersion, version)
	return err
}
