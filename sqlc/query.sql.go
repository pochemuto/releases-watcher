// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
)

const deleteAllActualAlbums = `-- name: DeleteAllActualAlbums :exec
DELETE FROM actual_album
`

func (q *Queries) DeleteAllActualAlbums(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllActualAlbums)
	return err
}

const deleteAllLocalAlbums = `-- name: DeleteAllLocalAlbums :exec
DELETE FROM album
`

func (q *Queries) DeleteAllLocalAlbums(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllLocalAlbums)
	return err
}

const getActualAlbums = `-- name: GetActualAlbums :many
SELECT id, artist, name, year, kind FROM actual_album
`

func (q *Queries) GetActualAlbums(ctx context.Context) ([]ActualAlbum, error) {
	rows, err := q.db.Query(ctx, getActualAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActualAlbum
	for rows.Next() {
		var i ActualAlbum
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.Name,
			&i.Year,
			&i.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAll = `-- name: GetAll :many
SELECT value, id FROM cache WHERE entity = $1
`

type GetAllRow struct {
	Value []byte
	ID    string
}

func (q *Queries) GetAll(ctx context.Context, entity string) ([]GetAllRow, error) {
	rows, err := q.db.Query(ctx, getAll, entity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRow
	for rows.Next() {
		var i GetAllRow
		if err := rows.Scan(&i.Value, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCache = `-- name: GetCache :one
SELECT value FROM cache WHERE entity = $1 AND id = $2
`

type GetCacheParams struct {
	Entity string
	ID     string
}

func (q *Queries) GetCache(ctx context.Context, arg GetCacheParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCache, arg.Entity, arg.ID)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const getLocalAlbums = `-- name: GetLocalAlbums :many
SELECT artist, name FROM album
`

func (q *Queries) GetLocalAlbums(ctx context.Context) ([]Album, error) {
	rows, err := q.db.Query(ctx, getLocalAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(&i.Artist, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalArtists = `-- name: GetLocalArtists :many
SELECT DISTINCT artist FROM album
`

func (q *Queries) GetLocalArtists(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getLocalArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artist string
		if err := rows.Scan(&artist); err != nil {
			return nil, err
		}
		items = append(items, artist)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertActualAlbum = `-- name: InsertActualAlbum :exec
INSERT INTO actual_album (id, artist, name, year, kind)
		 VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING
`

type InsertActualAlbumParams struct {
	ID     int64
	Artist *string
	Name   *string
	Year   *int32
	Kind   *string
}

func (q *Queries) InsertActualAlbum(ctx context.Context, arg InsertActualAlbumParams) error {
	_, err := q.db.Exec(ctx, insertActualAlbum,
		arg.ID,
		arg.Artist,
		arg.Name,
		arg.Year,
		arg.Kind,
	)
	return err
}

const insertCache = `-- name: InsertCache :exec
INSERT INTO cache (entity, id, value) VALUES ($1, $2, $3)
`

type InsertCacheParams struct {
	Entity string
	ID     string
	Value  []byte
}

func (q *Queries) InsertCache(ctx context.Context, arg InsertCacheParams) error {
	_, err := q.db.Exec(ctx, insertCache, arg.Entity, arg.ID, arg.Value)
	return err
}

const insertLocalAlbum = `-- name: InsertLocalAlbum :exec
INSERT INTO album (artist, name) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type InsertLocalAlbumParams struct {
	Artist string
	Name   string
}

func (q *Queries) InsertLocalAlbum(ctx context.Context, arg InsertLocalAlbumParams) error {
	_, err := q.db.Exec(ctx, insertLocalAlbum, arg.Artist, arg.Name)
	return err
}
