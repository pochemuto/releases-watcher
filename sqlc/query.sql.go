// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
)

const createActualAlbumPartition = `-- name: CreateActualAlbumPartition :exec
SELECT create_actual_album_partition($1::int)
`

func (q *Queries) CreateActualAlbumPartition(ctx context.Context, version int32) error {
	_, err := q.db.Exec(ctx, createActualAlbumPartition, version)
	return err
}

const createVersion = `-- name: CreateVersion :one
INSERT INTO version (published)
VALUES (FALSE)
RETURNING version_id,
	created_at,
	published
`

func (q *Queries) CreateVersion(ctx context.Context) (Version, error) {
	row := q.db.QueryRow(ctx, createVersion)
	var i Version
	err := row.Scan(&i.VersionID, &i.CreatedAt, &i.Published)
	return i, err
}

const deleteAllActualAlbums = `-- name: DeleteAllActualAlbums :exec
DELETE FROM actual_album
`

func (q *Queries) DeleteAllActualAlbums(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllActualAlbums)
	return err
}

const deleteAllLocalAlbums = `-- name: DeleteAllLocalAlbums :exec
DELETE FROM album
`

func (q *Queries) DeleteAllLocalAlbums(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllLocalAlbums)
	return err
}

const getActualAlbums = `-- name: GetActualAlbums :many
SELECT id, artist, name, year, kind, version_id
FROM actual_album
`

func (q *Queries) GetActualAlbums(ctx context.Context) ([]ActualAlbum, error) {
	rows, err := q.db.Query(ctx, getActualAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActualAlbum
	for rows.Next() {
		var i ActualAlbum
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.Name,
			&i.Year,
			&i.Kind,
			&i.VersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAll = `-- name: GetAll :many
SELECT value,
	id
FROM cache
WHERE entity = $1
`

type GetAllRow struct {
	Value []byte
	ID    string
}

func (q *Queries) GetAll(ctx context.Context, entity string) ([]GetAllRow, error) {
	rows, err := q.db.Query(ctx, getAll, entity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRow
	for rows.Next() {
		var i GetAllRow
		if err := rows.Scan(&i.Value, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCache = `-- name: GetCache :one
SELECT value
FROM cache
WHERE entity = $1
	AND id = $2
`

type GetCacheParams struct {
	Entity string
	ID     string
}

func (q *Queries) GetCache(ctx context.Context, arg GetCacheParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCache, arg.Entity, arg.ID)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const getExcludedAlbums = `-- name: GetExcludedAlbums :many
SELECT artist,
	album
FROM excluded_album
`

func (q *Queries) GetExcludedAlbums(ctx context.Context) ([]ExcludedAlbum, error) {
	rows, err := q.db.Query(ctx, getExcludedAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExcludedAlbum
	for rows.Next() {
		var i ExcludedAlbum
		if err := rows.Scan(&i.Artist, &i.Album); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExcludedArtists = `-- name: GetExcludedArtists :many
SELECT artist
FROM excluded_artist
`

func (q *Queries) GetExcludedArtists(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getExcludedArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artist string
		if err := rows.Scan(&artist); err != nil {
			return nil, err
		}
		items = append(items, artist)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalAlbums = `-- name: GetLocalAlbums :many
SELECT artist, name
FROM album
`

func (q *Queries) GetLocalAlbums(ctx context.Context) ([]Album, error) {
	rows, err := q.db.Query(ctx, getLocalAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(&i.Artist, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalArtists = `-- name: GetLocalArtists :many
SELECT DISTINCT artist
FROM album
`

func (q *Queries) GetLocalArtists(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getLocalArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var artist string
		if err := rows.Scan(&artist); err != nil {
			return nil, err
		}
		items = append(items, artist)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertActualAlbum = `-- name: InsertActualAlbum :exec
INSERT INTO actual_album (id, artist, name, year, kind, version_id)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT DO NOTHING
`

type InsertActualAlbumParams struct {
	ID        string
	Artist    *string
	Name      *string
	Year      *int32
	Kind      *string
	VersionID int32
}

func (q *Queries) InsertActualAlbum(ctx context.Context, arg InsertActualAlbumParams) error {
	_, err := q.db.Exec(ctx, insertActualAlbum,
		arg.ID,
		arg.Artist,
		arg.Name,
		arg.Year,
		arg.Kind,
		arg.VersionID,
	)
	return err
}

const insertCache = `-- name: InsertCache :exec
INSERT INTO cache (entity, id, value)
VALUES ($1, $2, $3)
`

type InsertCacheParams struct {
	Entity string
	ID     string
	Value  []byte
}

func (q *Queries) InsertCache(ctx context.Context, arg InsertCacheParams) error {
	_, err := q.db.Exec(ctx, insertCache, arg.Entity, arg.ID, arg.Value)
	return err
}

const insertLocalAlbum = `-- name: InsertLocalAlbum :exec
INSERT INTO album (artist, name)
VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type InsertLocalAlbumParams struct {
	Artist string
	Name   string
}

func (q *Queries) InsertLocalAlbum(ctx context.Context, arg InsertLocalAlbumParams) error {
	_, err := q.db.Exec(ctx, insertLocalAlbum, arg.Artist, arg.Name)
	return err
}
